%%
%% This file is part of Triq - Trifork QuickCheck
%%
%% Copyright (c) 2010 by Trifork
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%  
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%

-module(triq_dom).

-include_lib("eunit/include/eunit.hrl").

-define(DOM,'@').
-define(DEFAULT_PROP_PREFIX, "prop_").
-define(DELAY(X), fun()->X end).
-define(SIZED(Size,Gen),
	sized(fun(Size) -> Gen end)).
-define(SUCHTHAT_LOOPS,100).

-record('@',
	{kind,
	 pick   =fun error_pick/2,
	 shrink =fun error_shrink/2,
	 empty_ok = true
	}).


-record(list,  {elem}). 
-record(tuple, {elem}).
-record(vector,{size, elem}).
-record(binary,{size}).
-record(atom,{size}).
-record(oneof, {size, elems=[]}).
-record(resize,{size, dom}).
-record(bind,  {dom, body}).
-record(sized, {body}).
-record(return,{value}).
-record(suchthat,{dom,pred}).
-record(bound_domain,{dom1,val1,dom2,fun2,size}).
-record(choose,{min,max}).
-record(elements,{elems,size,picked=none}).

%% @type domain(). A domain of values.
-type domain(T) :: record(?DOM) | T.

%% generators
-export([list/1, tuple/1, int/0, real/0, sized/1, elements/1, any/0, atom/0, atom/1, choose/2,
	 oneof/1, boolean/0, char/0, return/1, vector/2, binary/1, binary/0, non_empty/1, resize/2]).

%% using a generator
-export([bind/2, suchthat/2, pick/2, shrink/2]).

%% utility
-export([foldn/3]).

%%
%% Default values for pic/shrink in ?DOM records
%%
error_pick(#'@'{kind=Kind},_) -> erlang:error({pick,Kind}).
error_shrink(#'@'{kind=Kind},_) -> erlang:error({shrink,Kind}).

-spec pick(domain(T), pos_integer()) -> {domain(T), T}.

%%
%% @doc The heart of the random structure generator; pick a value from the domain.
%%   Returns a pair of `{domain(T), T}' where the first component described
%%   the structure of the picked value.
%% @spec pick(domain(T), pos_integer()) -> {domain(T), T}
%%
pick(Dom=#'@'{pick=PickFun}, SampleSize) ->
    PickFun(Dom,SampleSize);

%%
%% A tuple is generated by generating each element
%%
pick({}=Empty, _) -> {Empty,Empty};
pick(T,SampleSize) when is_tuple(T) ->
    {DomList,List} = pick(tuple_to_list(T), SampleSize),
    {list_to_tuple(DomList), list_to_tuple(List)};

%%
%% for Lists, we traverse down the list and generate 
%% each head
%%
pick([], _) -> {[],[]};
pick([H|T], SampleSize) -> 
    {HDom,HVal} = pick(H,SampleSize),
    {TDom,TVal} = pick(T,SampleSize),
    {[HDom|TDom], [HVal|TVal]};

%%
%% Lazy elements...
%%
pick(F,SampleSize) when erlang:is_function(F,0) ->
    pick(F(),SampleSize);

%%
%% simple values that generate themselves
%%
pick(V,_) when is_atom(V);
	       is_number(V);
	       is_binary(V);
	       is_function(V);
	       is_bitstring(V)
	       ->
    {V,V}.



pick_test() ->
    case pick(int(), 10) of
	{Dom, Val} when Val >= -5, Val =< 5 ->
	    Dom = int()
    end.

pick_tuple_test() ->

    case pick({int(),int()}, 10) of
	{Dom, {Val1,Val2}} when is_integer(Val1), is_integer(Val2) ->
	    Dom = {int(), int()}
    end.

pick_lazy_test() ->
    case pick(?DELAY(int()), 10) of
	{_, Val} when Val >= -5, Val =< 5 ->
	    ok
    end.
	 

pick_list_test() ->

    case pick([int(),int()], 10) of
	{Dom, [Val1,Val2]} when is_integer(Val1), is_integer(Val2) ->
	    Dom = [int(), int()]
    end.
	 

pick_pair_test() ->	

    repeat( fun() ->
       case pick([choose(0,10) | {choose(0,10)}], 10) of
	   {Dom, [Int1| {Int2}]=Val} when is_integer(Int1),
					  is_integer(Int2) ->
	       
	       case shrink(Dom, Val) of
		   {_, [SInt1 | {SInt2}]} when SInt1<Int1; SInt2<Int2 -> ok; 
		   {_, [_ | {_}]} when Int1==0;Int2==0 -> ok
	       end
       
       end
    end,
	    20).



%%%
%%% Shrinking
%%%

shrink(Dom=#?DOM{shrink=SFun}, Val) ->
    SFun(Dom,Val);

shrink(_, Simple) when Simple =:= [];
		       Simple =:= {};
		       Simple =:= '';
		       Simple =:= << >>;
                       Simple =:= 0;
                       Simple =:= 0.0 ->

    {Simple,Simple};

shrink(TupDom,Tup) when is_tuple(TupDom), 
                        is_tuple(Tup), 
                        tuple_size(TupDom) =:= tuple_size(Tup) ->
    shrink_tuple_samesize(TupDom, Tup, 10);


%
% well-formed lists are shrunk using this case.
% the "length(X)>=0 tests if it is well-formed list" 
%
shrink(ListDom, List) when is_list(ListDom), is_list(List), length(List) >= 0 ->
    ?assert(length(ListDom) == length(List)),
    shrink_list_samesize(ListDom, List, length(List), 10);

%
% other non-well-formed lists [cons pairs] use this clause
%
shrink([_|_]=ListDom, [_|_]=List) ->
    shrink_pair(ListDom,List, 10);


%% finally, if the generator is the value itself, it simplifies to itself
shrink(Any,Any) -> {Any,Any}.

%%
%% support functions for the generic shrinking
%%

shrink_pair(ListDom,List,0) ->
    {ListDom,List};
shrink_pair([HDom|TDom]=ListDom, [H|T]=List, NAttempts) ->

    % choose if we shrink the head or the tail
    ShrinkHead = (random:uniform(2) =:= 1),
    ShrinkTail = (random:uniform(2) =:= 1),

    %% then do it
    %
    case 
	
	%% shrink head and/or tail
	{
          case ShrinkHead of 
	      true -> shrink(HDom,H);
	      false -> {HDom,H}
	  end
        ,
          case ShrinkTail of 
	      true -> shrink(TDom,T);
	      false -> {TDom,T}
	  end 
        }
	
	of
	
	%% it did not shrink
	{{_,H}, {_,T}} ->
	    shrink_pair(ListDom,List,NAttempts-1);
	    
	%% either H or T changed.
	{{HSDom,HS}, {TSDom,TS}} ->
	    {[HSDom|TSDom], [HS|TS]}
    end.

%%
%% We shrink tuples by turning it into a list and shrinking that...
%%
shrink_tuple_samesize(TupDom, Tup, NAttempts) ->
    ?assert(tuple_size(TupDom) =:= tuple_size(Tup)),
    ListDom = tuple_to_list(TupDom),
    List = tuple_to_list(Tup),
    {SDom,SList} = shrink_list_samesize(ListDom, List, tuple_size(Tup), NAttempts),
    { list_to_tuple(SDom), list_to_tuple(SList) }.


%%
%% Shrink a list by simplifying one or more of the elements.
%% 
shrink_list_samesize([],[],_,_) ->
    {[],[]};

shrink_list_samesize(ListDom,List,_,0) ->
    {ListDom,List};

shrink_list_samesize(ListDom,List,Length,NAttempts) when is_list(List) ->
    ?assert(length(ListDom) == length(List)),

    HowManyToShrink = random:uniform(Length+1),
    case shrink_list_members(ListDom, List, Length, HowManyToShrink) of

	% it did not shrink, try again
	{_,List} -> 
	    shrink_list_samesize(ListDom, List, Length, NAttempts-1);

	% else, we got a simpler list
	{_,_}=Result -> 
	    Result
    end.

%%
%% Given a list, shrink HowMany of it's elements, 
%% but don't reduce the list length
%%
shrink_list_members(ListDom, List, _, 0) -> {ListDom,List};
shrink_list_members(ListDom, List, Len, HowMany) when is_list(List), is_list(ListDom) ->

    ?assert(Len == length(List)),

    %%
    %% replace element at RemIdx with simplified one
    %%
    RemIdx = random:uniform(Len),    
    Elm = lists:nth(RemIdx, List),
    ElmDom = lists:nth(RemIdx, ListDom),

    {NextDom,NextList} = 
	case shrink(ElmDom,Elm) of
	    {_,Elm} -> {ListDom,List};
	    {SElmDom,SElm} ->
		Dom2  = lists:sublist(ListDom,RemIdx-1) ++ [SElmDom] ++ lists:sublist(ListDom,RemIdx+1,Len),
		List2 = lists:sublist(List,RemIdx-1) ++ [SElm] ++ lists:sublist(List,RemIdx+1,Len),
		{Dom2, List2}
	end,

    shrink_list_members(NextDom, NextList, Len, HowMany-1).


%%-------------------------------------------------------------------
%%
%% Now, the specifc domains
%%
%%-------------------------------------------------------------------

%%--------------------------------------------------------------------
%% @doc
%% Returns the domain of lists of the argument.  
%% For example, `list(int())' yields the domain of lists of integers.
%%
%% @spec list( domain() ) -> domain()
%% @end
%%--------------------------------------------------------------------
list(ElemDom) ->
    #'@'{kind=#list{elem=ElemDom}, pick=fun list_pick/2 }.

list_pick(#'@'{kind=#list{elem=ElemDom},empty_ok=EmptyOK}, 
	  SampleSize) ->

    OutLen = if EmptyOK =:= false ->
		     random:uniform(SampleSize);
		EmptyOK =:= true ->
		     random:uniform(SampleSize)-1
	     end,

    %%
    %% TODO: if ElemDom is "simple" no need to build template
    %%

    %% generate template Domain and corresponding List
    {ListDom,List} = 
	foldn( fun({Dom,T}) ->
		       {EDom,E} = pick(ElemDom,SampleSize),
		       {[EDom|Dom], [E|T]}
	       end,
	       {[],[]},
	       OutLen),

    shrinkable_list(ListDom, List, OutLen, EmptyOK).


%% oops, if length==1 and EmptyOK=false; just return the fixed list
shrinkable_list(ListDom, List, 1, false) ->
    {ListDom, List};

shrinkable_list(ListDom, List, Len, EmptyOK) ->
    ?assert(length(List) == length(ListDom)),
    ?assert(length(List) == Len),

    SDom = #'@'{kind={shrinkable_list, ListDom, Len}, shrink=fun list_shrink/2, empty_ok=EmptyOK},
    {SDom,List}.

list_shrink(#'@'{kind={shrinkable_list, ListDom, Len}, empty_ok=EmptyOK}, List) ->
    case shrink(ListDom,List) of
	{_, List} when EmptyOK, (Len>0) ->

	    RemIdx = random:uniform(Len),
	    shrinkable_list( without(RemIdx, ListDom), without(RemIdx, List), Len-1, EmptyOK);

	{ShrunkenListDom,ShrunkenList} -> 
	    io:format("shrunk ~p -> ~p [empty_ok=~p]~n", [List,ShrunkenList,EmptyOK]),
	    shrinkable_list(ShrunkenListDom, ShrunkenList, Len, EmptyOK)
    end.


%%
%% Generator for tuples
%%
tuple(ElemDom) ->
    #'@'{kind=#tuple{elem=ElemDom}, pick=fun tuple_pick/2 }.

tuple_pick(#'@'{kind=#tuple{elem=ElemDom},empty_ok=EmptyOK}, 
	  SampleSize) ->

    OutLen = if EmptyOK =:= false ->
		     random:uniform(SampleSize);
		EmptyOK =:= true ->
		     random:uniform(SampleSize)-1
	     end,

    %%
    %% TODO: if ElemDom is "simple" no need to build template
    %%

    %% generate template Domain and corresponding Tuple
    {ListDom,List} = 
	foldn( fun({Dom,T}) ->
		       {EDom,E} = pick(ElemDom,SampleSize),
		       {[EDom|Dom], [E|T]}
	       end,
	       {[],[]},
	       OutLen),

    shrinkable_tuple(list_to_tuple(ListDom), list_to_tuple(List), EmptyOK).


%% oops, if length==1 and EmptyOK=false; just return the fixed tuple
shrinkable_tuple(TupleDom, Tuple, false) when tuple_size(Tuple) =:= 1 ->
    {TupleDom, Tuple};

shrinkable_tuple(TupleDom, Tuple, EmptyOK) ->
    ?assert(tuple_size(Tuple) == tuple_size(TupleDom)),

    SDom = #'@'{kind={shrinkable_tuple, TupleDom}, shrink=fun tuple_shrink/2, empty_ok=EmptyOK},
    {SDom,Tuple}.

tuple_shrink(#'@'{kind={shrinkable_tuple, TupleDom}, empty_ok=EmptyOK}, Tuple) ->
    AllowSmaller = allow_smaller(tuple_size(Tuple), any, EmptyOK),
    case shrink(TupleDom,Tuple) of
	{_, Tuple} when AllowSmaller ->

	    RemIdx = random:uniform(tuple_size(Tuple)),
	    shrinkable_tuple( without(RemIdx, TupleDom), without(RemIdx, Tuple), EmptyOK);

	Result -> Result
    end.



%% @doc The domain of integers.
%% @spec(int() -> domain()).
int() ->
    #'@'{kind=int,
	 shrink=fun(Dom,Val) when Val>0 -> {Dom,Val-1};
		   (Dom,Val) when Val<0 -> {Dom,Val+1};
		   (Dom,0) -> {Dom,0} 
		end,
	 pick=fun(Dom,SampleSize) ->
		      {Dom, random:uniform(SampleSize) - (SampleSize div 2)}
	      end
	}.

%% @doc The domain of floats.
%% @spec(real() -> domain()).
real() ->
    #'@'{
      kind=real,
      pick=fun(Dom,SampleSize) -> {Dom, (random:uniform()*SampleSize) - (SampleSize / 2)} end,
      shrink=fun(Dom,Val) -> {Dom, Val/2.0} end
     }.


%% @doc The domain of booleans.
%% @spec(boolean() -> domain()).
boolean() ->
    #'@'{
      kind=boolean,
      pick=fun(Dom,_) -> {Dom, random:uniform(2)==1} end,
      shrink=fun(Dom,Val) -> {Dom, Val} end
     }.


char() ->
    #'@'{
      kind=char,
      pick=fun(Dom,_) -> 
 		     {Dom, $a + random:uniform($z - $a + 1)-1} 
	   end,
      shrink=fun(Dom,V) when V =< $c -> 
		     {Dom,V}; 
		(Dom,N) when N > $c, N =< $z -> 
		     {Dom,N - random:uniform(3)} 
	     end 
}.		     


-spec binary() -> domain(binary()).
binary() ->
    #'@'{kind=#binary{size=any},
	 pick=fun binary_pick/2,
	 shrink=fun binary_shrink/2}.

-spec binary(non_neg_integer()) -> domain(binary()).    
binary(Size) ->
    #'@'{kind=#binary{size=Size},
	 pick=fun binary_pick/2,
	 shrink=fun binary_shrink/2}.


binary_pick(#'@'{kind=#binary{size=Size}, empty_ok=EmptyOK}=BinDom, SampleSize) ->
    Sz = case Size of
	     any ->
		 case EmptyOK of
		     true ->
			 random:uniform(SampleSize)-1;
		     false ->
			 random:uniform(SampleSize)
		 end;
	     Size -> 
		 Size
	 end,
    BinValue = list_to_binary(foldn(fun(T) -> [random:uniform(256)-1 | T] end, 
				    [],
				    Sz)),
    {BinDom, BinValue}.


allow_smaller(Len,any,true) when Len>0 ->
    true;
allow_smaller(Len,any,false) when Len>1 ->
    true;
allow_smaller(_,_,_) ->
    false.


binary_shrink(#'@'{kind=#binary{size=Size}, empty_ok=EmptyOK}=BinDom, BinValue) ->
    List = binary_to_list(BinValue),
    Length = byte_size(BinValue),
    AllowSmaller = allow_smaller(Length,Size,EmptyOK) ,
    case shrink_list_with_elemdom(int(), List, Length, AllowSmaller) of
	List -> {BinDom, BinValue};
	NewList -> {BinDom, list_to_binary(NewList)}
    end.



-spec atom() -> domain(atom()).
atom() ->
    #'@'{kind=#atom{size=any},
	 pick=fun atom_pick/2,
	 shrink=fun atom_shrink/2}.

-spec atom(non_neg_integer()) -> domain(atom()).    
atom(Size) ->
    #'@'{kind=#atom{size=Size},
	 pick=fun atom_pick/2,
	 shrink=fun atom_shrink/2}.


atom_pick(#'@'{kind=#atom{size=Size}, empty_ok=EmptyOK}=AtomDom, SampleSize) ->
    Sz = case Size of
	     any ->
		 case EmptyOK of
		     true ->
			 random:uniform(min(SampleSize,256))-1;
		     false ->
			 random:uniform(min(SampleSize,256))
		 end;
	     Size -> 
		 Size
	 end,
    
    CharDom = char(),
    Fun=fun(T) -> {_,Char} = pick(CharDom,SampleSize), [Char | T] end,
    AtomValue = list_to_atom(foldn(Fun, [], Sz)),
    {AtomDom, AtomValue}.

min(A,B) when A<B -> A;
min(A,B) when B<A -> B;
min(A,B) when A==B -> A.


atom_shrink(#'@'{kind=#atom{size=Size}, empty_ok=EmptyOK}=AtomDom, AtomValue) ->
    List = atom_to_list(AtomValue),
    Length = length(List),
    AllowSmaller = allow_smaller(Length,Size,EmptyOK) ,
    case shrink_list_with_elemdom(char(), List, Length, AllowSmaller) of
	List -> {AtomDom, AtomValue};
	NewList -> {AtomDom, list_to_atom(NewList)}
    end.



vector(Size,ElemDom) ->
    #'@'{kind=#vector{size=Size,elem=ElemDom},
	 pick=fun vector_pick/2}.

vector_pick(#'@'{kind=#vector{size=Size,elem=ElemDom}}, SampleSize) ->
    foldn(fun({TDom,T}) ->
		  {HDom,H} = pick(ElemDom, SampleSize),
		  {[HDom|TDom], [H|T]}
	  end,
	  {[], []},
	  Size).
    


shrink_list_with_elemdom(ElemDom,List,Length,AllowSmaller) ->
    HowManyToShrink = random:uniform(Length),
    case shrink_list_members_generic(ElemDom, List, Length, HowManyToShrink) of

	%% can we remove an element?
	List when AllowSmaller ->
	    RemIdx = random:uniform(Length),
	    without(RemIdx, List);

	%% it changed!
	ShrunkenList ->
	    ShrunkenList
    end.
    

%%
%% Same, but when component element is fixed (also returns List, not {Dom,List})!
%%
-spec shrink_list_members_generic(domain(T), [T], non_neg_integer(), integer()) -> [T].
shrink_list_members_generic(_, List, _, 0) -> List;
shrink_list_members_generic(#'@'{}=ElemDom, List, Len, HowMany) ->
    ?assert(Len == length(List)),

    %%
    %% replace element at RemIdx with simplified one
    %%
    RemIdx = random:uniform(Len),    
    Elm = lists:nth(RemIdx, List),

    NextList = 
	case shrink(ElemDom,Elm) of
	    {_,Elm} -> 
		List;
	    {_,SElm} ->
		lists:sublist(List,RemIdx-1) ++ [SElm] ++ lists:sublist(List,RemIdx+1,Len)
	end,

    shrink_list_members_generic(ElemDom, NextList, Len, HowMany-1).

    


non_empty(#'@'{}=Dom) ->
    Dom#'@'{empty_ok=false}.


%% @doc Support function for the `LET(Vars,Dom1,Dom2)' macro.
-spec bind(domain(T::any()), 
	   fun( (T::any()) -> domain(D) )) -> domain(D).
bind(Gen1,FG2) -> 
    #'@'{kind=#bind{dom=Gen1,body=FG2},
	 pick = fun bind_pick/2
	}.

-spec bind_pick(domain(T),pos_integer()) -> T.
    
bind_pick(#'@'{kind=#bind{dom=Dom,body=Fun}}, SampleSize) ->
    {Dom1,Val1} = pick(Dom, SampleSize),
    {Dom2,Val2} = pick( Fun(Val1), SampleSize),
    
    { bound_domain(Dom1,Val1,Dom2,Fun, SampleSize), Val2 }.

bound_domain(Dom1,Val1,Dom2,Fun,SampleSize) ->
    #'@'{kind=#bound_domain{dom1=Dom1,val1=Val1,dom2=Dom2,fun2=Fun,size=SampleSize},
	 shrink= fun bound_shrink/2 
	}.

bound_shrink(#'@'{kind=#bound_domain{dom1=Dom1,val1=Val1,dom2=Dom2,fun2=Fun,size=SampleSize}}, Val2) ->
    case shrink(Dom1,Val1) of

	% it did not shrink val1
	{_,Val1} ->
	    % try to shrink the secondary domain
	    shrink(Dom2,Val2);
	
	% Val1 did shrink! 
	{SDom1,SVal1} ->
	    % pick a new value from the secondary domain
	    {SDom2,SVal2} = pick( Fun(SVal1), SampleSize),

	    % and return the new bound domain
	    { bound_domain(SDom1,SVal1,SDom2,Fun, SampleSize), SVal2 }
    end.


-spec suchthat(domain(T),fun((T) -> boolean())) -> domain(T).
	     
suchthat(Dom,Fun) ->
    #'@'{kind=#suchthat{dom=Dom,pred=Fun},
	 pick=fun(#'@'{kind=#suchthat{dom=Dom1,pred=Fun1}},SampleSize) -> 
		      suchthat_loop(?SUCHTHAT_LOOPS,Dom1,Fun1,SampleSize) 
	      end
	}.			   

suchthat_loop(0,_,_,_) ->
    erlang:exit(suchthat_failed);

suchthat_loop(N,Dom,Fun,SampleSize) ->
    {ValDom,Val} = pick(Dom,SampleSize),
    case Fun(Val) of
	true -> {ValDom,Val};
	_ -> suchthat_loop(N-1, Dom, Fun, SampleSize)
    end.


smaller(Domain) ->
    ?SIZED(SZ, resize(random:uniform((SZ div 2)+1), Domain)).


-spec any() -> domain(any()).
any()  ->
    oneof([int(), real(), boolean(), atom(), 

	   [smaller(?DELAY(any())) | smaller(?DELAY(any()))],

	   %% list(any()), but with a size in the range 1..GenSize
	   list(smaller(?DELAY(any()))),

	   tuple(smaller(?DELAY(any())))

	  ]).

-spec oneof(list(domain(any()))) -> domain(any()).
    
oneof(DomList) when is_list(DomList) ->
    #'@'{kind=#oneof{elems=DomList, size=length(DomList)},
	 pick=fun oneof_pick/2
	 }.

oneof_pick(#'@'{kind=#oneof{elems=DomList, size=Length}}, SampleSize) ->
    Dom = lists:nth(random:uniform(Length), DomList),
    pick(Dom, SampleSize).

%% @doc Returns the doamin of Val.
-spec return(Val::Type) -> domain(Type).
return(Val) -> 
    #'@'{kind=#return{value=Val},
	 pick  = fun(#'@'{kind=#return{value=V}}=Dom,_) -> {Dom,V} end,
	 shrink  = fun(Dom,V) -> {Dom,V} end
	}.

-spec(sized( fun((integer()) -> domain(T)) ) -> domain(T)).	     
sized(Fun) ->
    #'@'{kind=#sized{body=Fun},
	 pick=fun(#'@'{kind=#sized{body=F}},GS) -> pick(F(GS),GS) end
	}. 

resize(Sz,Dom) ->
    #'@'{kind=#resize{dom=Dom,size=Sz},
	 pick=fun(#'@'{kind=#resize{dom=D,size=SampleSize}},_) -> 
		      pick(D,SampleSize) 
	      end
	}. 
    
-spec choose(M::integer(), N::integer()) -> domain(integer()).
choose(M,N) when is_integer(M), is_integer(N), M<N ->
    #'@'{kind={choose,M,N},
	 pick = fun choose_pick/2,
	 shrink = fun choose_shrink/2
	}.

choose_pick(#'@'{kind=#choose{min=M,max=N}}=Dom, _) ->
    Value = random:uniform(N-M+1) - 1 + M,
    {Dom,Value}.

choose_shrink(#'@'{kind=#choose{min=M}}=Dom, Value) when Value > M ->
    {Dom,Value-1};
choose_shrink(#'@'{kind=#choose{min=M}}=Dom, M) ->
    {Dom,M}.

%% @doc Generates a member of the list `L'.  Shrinks towards the first element of the list.
-spec elements([T,...]) -> domain(T).	      
elements(L) when is_list(L), length(L)>0 ->
    #'@'{kind=#elements{elems=L,size=length(L)}, 
	 pick = fun elements_pick/2,
	 shrink = fun elements_shrink/2
	 }.

-spec elements_pick(domain(T), pos_integer()) -> {domain(T), T}.    
elements_pick(#'@'{kind=#elements{elems=Elems,size=Length}=Kind}=Dom, _) ->
    Picked = random:uniform(Length),
    Value = lists:nth(Picked,Elems),
    { Dom#'@'{kind=Kind#elements{picked=Picked}},
      Value }.

elements_shrink(#'@'{kind=#elements{elems=Elems,picked=Picked}=Kind}=Dom, _) when Picked > 1 ->
    Value = lists:nth(Picked-1,Elems),
    { Dom#'@'{kind=Kind#elements{picked=Picked-1}},
      Value };
elements_shrink(Dom,Value) ->
    { Dom, Value }.







%%
%% Utility funcitons
%%


foldn(_,Acc,0) -> Acc;
foldn(Fun,Acc,Count) ->
    foldn(Fun, Fun(Acc), Count-1).
    
%% remove the RemIdx'th element of List [1-indexed]
without(RemIdx,List) when is_list(List) ->
    {First,Rest} = lists:split(RemIdx-1,List),
    First ++ tl(Rest);

without(RemIdx,Tup) when is_tuple(Tup) ->
    list_to_tuple(without(RemIdx, tuple_to_list(Tup))).


repeat(_,0) ->
    ok;
repeat(Fun,N) ->
    Fun(),
    repeat(Fun,N-1).
